/*******************************************************************************
*
* Copyright 2018 Stefan Majewsky <majewsky@gmx.net>
*
* This program is free software: you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option) any later
* version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
* A PARTICULAR PURPOSE. See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along with
* this program. If not, see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

use std;

pub enum CursorAction {
    Insert(String),
    //TODO replace "Char" by "GraphemeCluster" or sth like that
    DeletePreviousChar, //Backspace key
    DeleteNextChar,     //Delete key
    GotoPreviousChar,   //Left arrow key
    GotoNextChar,       //Right arrow key
}

#[derive(PartialEq,Eq)]
pub enum CursorActionResult {
    Unchanged,
    Changed,
    LineCompleted(String),
}

bitflags! {
    ///Indicates what a Section is used for.
    pub struct Disposition: u32 {
        ///Section contains output from client programs. When a client program writes text into a
        ///frame, it will be appended to the bottom-most section with a `Display` disposition.
        const NORMAL_OUTPUT = 0x0001;
        ///Bit mask for flags indicating output behavior.
        const OUTPUT_MASK = 0x000F;
        ///Section contains input being prepared by the user for a frame that is operating in
        ///canonical input mode.
        const CANONICAL_INPUT = 0x0010;
        ///Section accepts raw input events from the user.
        const RAW_INPUT = 0x0020;
        ///Bit mask for flags indicating input behavior.
        const INPUT_MASK = 0x00F0;
    }
}

///Unique identifier for a section. This is a separate type to ensure that it is
///only generated by Document.make_section().
#[derive(PartialEq, Eq, Hash, Clone, Copy)]
pub struct SectionID(u64);

impl SectionID {
    pub fn new() -> SectionID {
        SectionID(0)
    }

    pub fn incr(&mut self) {
        self.0 += 1;
    }
}

///A section is some amount of text that appears on screen, starting at the
///beginning of a line and ending at the end of a line.
pub struct Section {
    id: SectionID,
    disposition: Disposition,
    text: String,
    cursor: usize,
    ///This counter increases whenever this section is changed. It is used to
    ///indicate to the view when re-layouting is necessary.
    generation: u64,
}

impl Section {
    ///Use Document::make_section() instead.
    pub fn new(text: String, id: SectionID, disposition: Disposition) -> Section {
        let len = text.len();
        Section {
            id: id,
            disposition: disposition,
            text: text,
            cursor: len,
            generation: 0,
        }
    }

    pub fn id(&self) -> SectionID {
        self.id
    }
    pub fn disposition(&self) -> Disposition {
        self.disposition
    }
    pub fn text(&self) -> &str {
        self.text.as_str()
    }
    pub fn cursor(&self) -> usize {
        self.cursor
    }
    pub fn generation(&self) -> u64 {
        self.generation
    }

    ///Appends additional output to this section.
    ///NOTE: Can only be used with disposition() == Disposition::NORMAL_OUTPUT.
    ///TODO: split Section into subtypes for each valid disposition
    pub fn append_text<T>(&mut self, text: T)
        where String: Extend<T> {
        self.text.extend(Some(text));
        self.generation += 1;
    }

    ///Returns whether the text in this section has changed.
    ///NOTE: Can only be used with disposition() == Disposition::CANONICAL_INPUT.
    ///TODO: split Section into subtypes for each valid disposition
    pub fn execute_cursor_action(&mut self, action: CursorAction) -> CursorActionResult {
        let result = self.execute_cursor_action_priv(action);
        if result != CursorActionResult::Unchanged {
            self.generation += 1;
        }
        result
    }

    fn execute_cursor_action_priv(&mut self, action: CursorAction) -> CursorActionResult {
        use self::CursorAction::*;
        use self::CursorActionResult::*;
        match action {
            Insert(ref text) => {
                self.text.insert_str(self.cursor, text);
                self.cursor = self.cursor + text.len();
                if self.text.ends_with("\n") {
                    let mut value = String::new();
                    std::mem::swap(&mut value, &mut self.text);
                    self.cursor = 0;
                    LineCompleted(value)
                } else {
                    Changed
                }
            },
            DeletePreviousChar | GotoPreviousChar => {
                if self.cursor == 0 { return Unchanged; }
                //search for start of previous char
                self.cursor -= 1;
                while !self.text.is_char_boundary(self.cursor) {
                    self.cursor -= 1;
                }
                if let DeletePreviousChar = action {
                    self.text.remove(self.cursor);
                }
                Changed
            },
            DeleteNextChar => {
                if self.cursor == self.text.len() { return Unchanged; }
                self.text.remove(self.cursor); //cursor does not move
                Changed
            },
            GotoNextChar => {
                if self.cursor == self.text.len() { return Unchanged; }
                self.cursor += 1;
                while !self.text.is_char_boundary(self.cursor) {
                    self.cursor += 1;
                }
                Changed
            },
        }
    }
}
