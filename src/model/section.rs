/*******************************************************************************
*
* Copyright 2018 Stefan Majewsky <majewsky@gmx.net>
*
* This program is free software: you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option) any later
* version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
* A PARTICULAR PURPOSE. See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along with
* this program. If not, see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

pub enum CursorAction {
    Insert(String),
    //TODO replace "Char" by "GraphemeCluster" or sth like that
    DeletePreviousChar, //Backspace key
    DeleteNextChar,     //Delete key
    GotoPreviousChar,   //Left arrow key
    GotoNextChar,       //Right arrow key
}

///Unique identifier for a section. This is a separate type to ensure that it is
///only generated by Document.make_section().
#[derive(PartialEq, Eq, Hash, Clone, Copy)]
pub struct SectionID(u64);

impl SectionID {
    pub fn new() -> SectionID {
        SectionID(0)
    }

    pub fn incr(&mut self) {
        self.0 += 1;
    }
}

///A section is some amount of text that appears on screen, starting at the
///beginning of a line and ending at the end of a line.
pub struct Section {
    id: SectionID,
    text: String,
    cursor: usize,
    ///This counter increases whenever this section is changed. It is used to
    ///indicate to the view when re-layouting is necessary.
    generation: u64,
}

impl Section {
    ///Use Document::make_section() instead.
    pub fn new(text: String, id: SectionID) -> Section {
        let len = text.len();
        Section {
            id: id,
            text: text,
            cursor: len,
            generation: 0,
        }
    }

    pub fn id(&self) -> SectionID {
        self.id
    }
    pub fn text(&self) -> &str {
        self.text.as_str()
    }
    pub fn cursor(&self) -> usize {
        self.cursor
    }
    pub fn generation(&self) -> u64 {
        self.generation
    }

    ///Returns whether the text in this section has changed.
    pub fn execute_cursor_action(&mut self, action: CursorAction) -> bool {
        let changed = self.execute_cursor_action_priv(action);
        if changed {
            self.generation += 1;
        }
        changed
    }

    fn execute_cursor_action_priv(&mut self, action: CursorAction) -> bool {
        use self::CursorAction::*;
        match action {
            Insert(ref text) => {
                self.text.insert_str(self.cursor, text);
                self.cursor = self.cursor + text.len();
                true
            },
            DeletePreviousChar | GotoPreviousChar => {
                if self.cursor == 0 { return false; }
                //search for start of previous char
                self.cursor -= 1;
                while !self.text.is_char_boundary(self.cursor) {
                    self.cursor -= 1;
                }
                if let DeletePreviousChar = action {
                    self.text.remove(self.cursor);
                }
                true
            },
            DeleteNextChar => {
                if self.cursor == self.text.len() { return false; }
                self.text.remove(self.cursor); //cursor does not move
                true
            },
            GotoNextChar => {
                if self.cursor == self.text.len() { return false; }
                self.cursor += 1;
                while !self.text.is_char_boundary(self.cursor) {
                    self.cursor += 1;
                }
                true
            },
        }
    }
}
